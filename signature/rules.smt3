(include "./theory.smt3")

(declare-rule context ((ctx Bool) (ctxOld Bool))
  :premises (ctx ctxOld)
  :conclusion (alf.concat @ctx.is ctx ctxOld)
)

; Rule: assume is native

; Note: The hole here does not allow for args or premises.
(declare-rule hole ((Ls Bool :list))
  :args ((@cl Ls))
  :conclusion (@cl Ls)
)

(declare-rule true ()
  :args ((@cl true))
  :conclusion (@cl true)
)

(declare-rule false ()
  :args ((@cl (not false)))
  :conclusion (@cl (not false))
)

(program check_not_not ((phi Bool))
    (Bool) Bool
    (
    ((check_not_not (@cl (not (not (not phi))) phi)) true)
    ((check_not_not (@cl phi (not (not (not phi))))) true)
    )
)
(declare-rule not_not ((CL Bool))
  :args (CL)
  :requires (((check_not_not CL) true))
  :conclusion CL
)

;TODO
(program check_resolution ((Cs Bool) (CL Bool))
  (Bool Bool) Bool
  (
   ((check_resolution Cs CL) true)
  )
)

;TRUST
(declare-rule th_resolution ((Cs Bool) (CL Bool))
  :premise-list Cs and
  :args (CL)
  :requires (((check_resolution Cs CL) true))
  :conclusion CL
)

;TRUST
(declare-rule resolution ((Cs Bool) (CL Bool))
  :premise-list Cs and
  :args (CL)
  :requires (((check_resolution Cs CL) true))
  :conclusion CL
)

;TODO
(program check_tautology ((CL1 Bool))
  (Bool) Bool
  (
   ((check_tautology CL1) true)
  )
)

;TRUST
(declare-rule tautology ((CL1 Bool))
  :premises (CL1)
  :args ((@cl true))
  :requires (((check_tautology CL1) true))
  :conclusion (@cl true)
)

;TODO
(program check_contraction ((CL1 Bool) (CL Bool))
  (Bool Bool) Bool
  (
   ((check_contraction CL1 CL) true)
  )
)

;TRUST
(declare-rule contraction ((CL1 Bool) (CL Bool))
  :premises (CL1)
  :args (CL)
  :requires (((check_contraction CL1 CL) true))
  :conclusion CL
)

(declare-rule subproof ((F Bool) (G Bool))
  :assumption F
  :premises (G)
  :args ((@cl (=> F G)))
  :conclusion (@cl (=> F G))
)

;TODO
(program check_la_generic ((coeffs Real) (CL Bool))
  (Real Bool) Bool
  (
   ((check_la_generic coeffs CL) true)
  )
)

;TRUST
(declare-rule la_generic ((CL Bool) (coeffs Real))
  :args (CL coeffs)
  :requires (((check_la_generic coeffs CL) true))
  :conclusion CL
)

;TODO
(program check_lia_generic ((CL Bool))
  (Bool) Bool
  (
   ((check_lia_generic CL) true)
  )
)

;TRUST
(declare-rule lia_generic ((CL Bool))
  :args (CL)
  :requires (((check_lia_generic CL) true))
  :conclusion CL
)

(declare-rule la_disequality ((t1 Real) (t2 Real))
  :args ((@cl (or (= t1 t2) (not (<= t1 t2)) (not (<= t2 t1)))))
  :conclusion (@cl (or (= t1 t2) (not (<= t1 t2)) (not (<= t2 t1))))
)

(declare-rule la_totality ((t1 Real) (t2 Real))
  :args ((@cl (or (<= t1 t2) (<= t2 t1))))
  :conclusion (@cl (or (<= t1 t2) (<= t2 t1)))
)

;TODO
(program check_la_tautology ((CL Bool))
  (Bool) Bool
  (
   ((check_la_tautology CL) true)
  )
)

;TRUST
(declare-rule la_tautology ((CL Bool))
  :args (CL)
  :requires (((check_la_tautology CL) true))
  :conclusion CL
)

;TODO
(program check_bind ((ctx Bool) (xs @VarList) (ys @VarList))
  (Bool @VarList @VarList) Bool
  (
   ((check_bind ctx xs ys) true)
  )
)

;TRUST
(declare-rule bind ((ctx Bool) (xs @VarList) (ys @VarList) (T Type) (phi T) (phiP T))
  :assumption ctx
  :premises ((@cl (= phi phiP)))
  :args ((@cl (= (forall xs phi) (forall ys phiP))))
  :requires (((check_bind ctx xs ys) true))
  :conclusion (@cl (= (forall xs phi) (forall ys phiP)))
)

;TODO
(program check_sko_ex ((ctx Bool) (xs @VarList))
  (Bool @VarList) Bool
  (
   ((check_sko_ex ctx xs) true)
  )
)

;TRUST
(declare-rule sko_ex ((ctx Bool) (xs @VarList) (phi Bool) (psi Bool))
  :assumption ctx
  :premises ((@cl (= phi psi)))
  :args ((@cl (= (exists xs phi) psi)))
  :requires (((check_sko_ex ctx xs) true))
  :conclusion (@cl (= (exists xs phi) psi))
)

;TODO
(program check_sko_forall ((ctx Bool) (xs @VarList))
  (Bool @VarList) Bool
  (
   ((check_sko_forall ctx xs) true)
  )
)

;TRUST
(declare-rule sko_forall ((ctx Bool) (xs @VarList) (phi Bool) (psi Bool))
  :assumption ctx
  :premises ((@cl (= phi psi)))
  :args ((@cl (= (forall xs phi) psi)))
  :requires (((check_sko_forall ctx xs) true))
  :conclusion (@cl (= (forall xs phi) psi))
)

;TODO
(program check_forall_inst ((xs @VarList) (P Bool) (PP Bool))
  (@VarList Bool Bool) Bool
  (
   ((check_forall_inst xs P PP) true)
  )
)

;TRUST
(declare-rule forall_inst ((P Bool) (PP Bool) (xs @VarList))
  :args ((@cl (or (not (forall xs P) PP))))
  :requires (((check_forall_inst xs P PP) true))
  :conclusion (@cl (or (not (forall xs P) PP)))
)

;TODO
(program check_refl ((ctx Bool) (T Type) (t1 T) (t2 T))
  (Bool T T) Bool
  (
   ((check_refl ctx t1 t2) true)
  )
)

;TRUST
(declare-rule refl ((ctx Bool) (T Type) (t1 T) (t2 T))
  :premises (ctx)
  :args ((@cl (= t1 t2)))
  :requires (((check_refl ctx t1 t2) true))
  :conclusion (@cl (= t1 t2))
)

(program last_eq_right ((T Type) (t1 T) (t2 T) (eqs Bool))
  (Bool) Bool
  (
    ((last_eq_right (and (@cl (= t1 t2)) true)) t2)
    ((last_eq_right (and (@cl (= t1 t2)) eqs)) (last_eq_right eqs))
  )
)

(program make_trans ((T Type) (t1 T) (t2 T) (eqs Bool :list))
  (Bool) Bool
  (
   ((make_trans (and (@cl (= t1 t2) true))) (= t1 t2))
   ((make_trans (and (@cl (= t1 t2) eqs))) (= t1 (last_eq_right eqs)))
  )
)

;TODO what about scopes here? can a premise come from an outers scope
;TODO: implement mkTrans
(declare-rule trans ((Eqs Bool))
  :premise-list Eqs and
  :args ((@cl (make_trans Eqs)))
  :conclusion (@cl (make_trans Eqs))
)

;TODO
(program check_cong ((Eqs Bool) (CEq Bool))
  (Bool Bool) Bool
  (
   ((check_cong Eqs CEq) true)
  )
)

;TRUST
(declare-rule cong ((Eqs Bool) (CEq Bool))
  :premise-list Eqs and
  :args ((@cl CEq)) ; CEq is an equality
  :requires (((check_cong Eqs CEq) true))
  :conclusion (@cl CEq)
)

(declare-rule eq_reflexive ((T Type) (t T))
  :args ((@cl (= t t)))
  :conclusion (@cl (= t t))
)

;TODO
(program check_eq_transitive ((CL Bool))
  (Bool) Bool
  (
   ((check_eq_transitive CL) true)
  )
)

;TRUST
(declare-rule eq_transitive ((CL Bool))
  :args (CL)
  :requires (((check_eq_transitive CL) true))
  :conclusion CL
)

;TODO
(program check_eq_congruent ((CL Bool))
  (Bool) Bool
  (
   ((check_eq_congruent CL) true)
  )
)

;TRUST
(declare-rule eq_congruent ((CL Bool))
  :args (CL)
  :requires (((check_eq_congruent CL) true))
  :conclusion CL
)

;TODO
(program check_eq_congruent_pred ((CL Bool))
  (Bool) Bool
  (
   ((check_eq_congruent_pred CL) true)
  )
)

;TRUST
(declare-rule eq_congruent_pred ((CL Bool))
  :args (CL)
  :requires (((check_eq_congruent_pred CL) true))
  :conclusion CL
)

;TODO
(program check_qnt_cnf ((phi Bool) (phiP Bool) (xs @VarList) (xsP @VarList))
  (@VarList Bool @VarList Bool) Bool
  (
   ((check_qnt_cnf xs phi xsP phiP) true)
  )
)

;TRUST
(declare-rule qnt_cnf ((phi Bool) (phiP Bool) (xs @VarList) (xsP @VarList))
  :args ((@cl (or (not (forall xs phi)) (forall xsP phiP))))
  :requires (((check_qnt_cnf xs phi xsP phiP) true))
  :conclusion (@cl (or (not (forall xs phi)) (forall xsP phiP)))
)

;TODO
(program contains ((inList Bool) (phi Bool))
  (Bool Bool) Bool
  (
   ((contains inList phi) true)
  )
)

; TODO: this overloads PandP
;TRUST
(declare-rule and ((C Bool) (CN Bool :list) (phi Bool))
  :premises ((@cl (and C CN)))
  :args ((@cl phi))
  :requires (((contains (and C CN) phi) true))
  :conclusion (@cl phi)
)

;TRUST
(declare-rule not_or ((C Bool) (CN Bool :list) (phi Bool))
  :premises ((@cl (not (or C CN))))
  :args ((@cl (not phi)))
  :requires (((contains (or C CN) phi) true))
  :conclusion (@cl (not phi))
)

;TODO
(program check_or ((ors Bool) (clause Bool))
  (Bool Bool) Bool
  (
   ((check_or ors clause) true)
  )
)

; TODO: this overloads PorP
;TRUST
(declare-rule or ((C Bool) (CN Bool :list) (CP Bool) (CNP Bool :list))
  :premises ((@cl (or C CN)))
  :args ((@cl CP CNP))
  :requires (((check_or (or C CN) (@cl CP CNP)) true))
  :conclusion (@cl CP CNP)
)

;TODO true if CL2 is a permuation of CL1
(program clEqual ((CL1 Bool) (CL2 Bool))
  (Bool Bool) Bool
  (
   ((clEqual CL1 CL2) true)
  )
)

;TODO: test this is likely wrong
(program transform_not_and ((l Bool) (ls Bool :list))
  (Bool Bool) Bool
  (
   ((transform_not_and l ls) (@cl (not l) (transform_not_and ls)))
  )
)

;TODO implement transform_not_and
(declare-rule not_and ((CL Bool) (C Bool) (CN Bool :list))
  :premises ((@cl (not (and C CN))))
  :args (CL)
  :requires (((clEqual (transform_not_and (and C CN)) CL) true))
  :conclusion CL
)

;TRUST
(declare-rule xor1 ((CL Bool) (phi1 Bool) (phi2 Bool))
  :premises ((@cl (xor phi1 phi2)))
  :args (CL)
  :requires (((clEqual (@cl phi1 phi2) CL) true))
  :conclusion CL
)

;TRUST
(declare-rule xor2 ((CL Bool) (phi1 Bool) (phi2 Bool))
  :premises ((@cl (xor phi1 phi2)))
  :args (CL)
  :requires (((clEqual (@cl (not phi1) (not phi2)) CL) true))
  :conclusion CL
)

;TRUST
(declare-rule not_xor1 ((CL Bool) (phi1 Bool) (phi2 Bool))
  :premises ((@cl (not (xor phi1 phi2))))
  :args (CL)
  :requires (((clEqual (@cl phi1 (not phi2)) CL) true))
  :conclusion CL
)

;TRUST
(declare-rule not_xor2 ((CL Bool) (phi1 Bool) (phi2 Bool))
  :premises ((@cl (not (xor phi1 phi2))))
  :args (CL)
  :requires (((clEqual (@cl (not phi1) phi2) CL) true))
  :conclusion CL
)

;TRUST
(declare-rule implies ((CL Bool) (phi1 Bool) (phi2 Bool))
  :premises ((@cl (=> phi1 phi2)))
  :args (CL)
  :requires (((clEqual (@cl (not phi1) phi2) CL) true))
  :conclusion CL
)

(declare-rule not_implies1 ((CL Bool) (phi1 Bool) (phi2 Bool))
  :premises ((@cl (not (=> phi1 phi2))))
  :args ((@cl phi1))
  :conclusion (@cl phi1)
)

(declare-rule not_implies2 ((CL Bool) (phi1 Bool) (phi2 Bool))
  :premises ((@cl (not (=> phi1 phi2))))
  :args ((@cl (not phi2)))
  :conclusion (@cl (not phi2))
)

;TRUST
(declare-rule equiv1 ((CL Bool) (phi1 Bool) (phi2 Bool))
  :premises ((@cl (= phi1 phi2)))
  :args (CL)
  :requires (((clEqual (@cl (not phi1) phi2) CL) true))
  :conclusion CL
)

;TRUST
(declare-rule equiv2 ((CL Bool) (phi1 Bool) (phi2 Bool))
  :premises ((@cl (= phi1 phi2)))
  :args (CL)
  :requires (((clEqual (@cl phi1 (not phi2)) CL) true))
  :conclusion CL
)

;TRUST
(declare-rule not_equiv1 ((CL Bool) (phi1 Bool) (phi2 Bool))
  :premises ((@cl (not (= phi1 phi2))))
  :args (CL)
  :requires (((clEqual (@cl phi1 phi2) CL) true))
  :conclusion CL
)

;TODO
(program check_and_pos ((CL Bool))
  (Bool) Bool
  (
   ((check_and_pos CL) true)
  )
)

;TRUST
(declare-rule and_pos ((CL Bool))
  :args (CL)
  :requires (((check_and_pos CL) true))
  :conclusion CL
)

;TODO
(program check_and_neg ((CL Bool))
  (Bool) Bool
  (
   ((check_and_neg CL) true)
  )
)

;TRUST
(declare-rule and_neg ((CL Bool))
  :args (CL)
  :requires (((check_and_neg CL) true))
  :conclusion CL
)

;TODO
(program check_or_pos ((CL Bool))
  (Bool) Bool
  (
   ((check_or_pos CL) true)
  )
)

;TRUST
(declare-rule or_pos ((CL Bool))
  :args (CL)
  :requires (((check_or_pos CL) true))
  :conclusion CL
)

;TODO
(program check_or_neg ((CL Bool))
  (Bool) Bool
  (
   ((check_or_neg CL) true)
  )
)

;TRUST
(declare-rule or_neg ((CL Bool))
  :args (CL)
  :requires (((check_or_neg CL) true))
  :conclusion CL
)

;TODO
(program check_xor_pos1 ((CL Bool))
  (Bool) Bool
  (
   ((check_xor_pos1 CL) true)
  )
)

;TRUST
(declare-rule xor_pos1 ((CL Bool))
  :args (CL)
  :requires (((check_xor_pos1 CL) true))
  :conclusion CL
)

;TODO
(program check_xor_pos2 ((CL Bool))
  (Bool) Bool
  (
   ((check_xor_pos2 CL) true)
  )
)

;TRUST
(declare-rule xor_pos2 ((CL Bool))
  :args (CL)
  :requires (((check_xor_pos2 CL) true))
  :conclusion CL
)

;TODO
(program check_xor_neg1 ((CL Bool))
  (Bool) Bool
  (
   ((check_xor_neg1 CL) true)
  )
)

;TRUST
(declare-rule xor_neg1 ((CL Bool))
  :args (CL)
  :requires (((check_xor_neg1 CL) true))
  :conclusion CL
)

;TODO
(program check_xor_neg2 ((CL Bool))
  (Bool) Bool
  (
   ((check_xor_neg2 CL) true)
  )
)

;TRUST
(declare-rule xor_neg2 ((CL Bool))
  :args (CL)
  :requires (((check_xor_neg2 CL) true))
  :conclusion CL
)

;TODO
(program check_implies_pos ((CL Bool))
  (Bool) Bool
  (
   ((check_implies_pos CL) true)
  )
)

;TRUST
(declare-rule implies_pos ((CL Bool))
  :args (CL)
  :requires (((check_implies_pos CL) true))
  :conclusion CL
)

;TODO
(program check_implies_neg1 ((CL Bool))
  (Bool) Bool
  (
   ((check_implies_neg1 CL) true)
  )
)

;TRUST
(declare-rule implies_neg1 ((CL Bool))
  :args (CL)
  :requires (((check_implies_neg1 CL) true))
  :conclusion CL
)

;TODO
(program check_implies_neg2 ((CL Bool))
  (Bool) Bool
  (
   ((check_implies_neg2 CL) true)
  )
)

;TRUST
(declare-rule implies_neg2 ((CL Bool))
  :args (CL)
  :requires (((check_implies_neg2 CL) true))
  :conclusion CL
)

;TODO
(program check_equiv_pos1 ((CL Bool))
  (Bool) Bool
  (
   ((check_equiv_pos1 CL) true)
  )
)

;TRUST
(declare-rule equiv_pos1 ((CL Bool))
  :args (CL)
  :requires (((check_equiv_pos1 CL) true))
  :conclusion CL
)

;TODO
(program check_equiv_pos2 ((CL Bool))
  (Bool) Bool
  (
   ((check_equiv_pos2 CL) true)
  )
)

;TRUST
(declare-rule equiv_pos2 ((CL Bool))
  :args (CL)
  :requires (((check_equiv_pos2 CL) true))
  :conclusion CL
)

;TODO
(program check_equiv_neg1 ((CL Bool))
  (Bool) Bool
  (
   ((check_equiv_neg1 CL) true)
  )
)

;TRUST
(declare-rule equiv_neg1 ((CL Bool))
  :args (CL)
  :requires (((check_equiv_neg1 CL) true))
  :conclusion CL
)

;TODO
(program check_equiv_neg2 ((CL Bool))
  (Bool) Bool
  (
   ((check_equiv_neg2 CL) true)
  )
)

;TRUST
(declare-rule equiv_neg2 ((CL Bool))
  :args (CL)
  :requires (((check_equiv_neg2 CL) true))
  :conclusion CL
)

;TRUST
(declare-rule ite1 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (CL Bool))
  :premises ((@cl (ite phi1 phi2 phi3)))
  :args (CL)
  :requires (((clEqual (@cl phi1 phi3) CL) true))
  :conclusion CL
)

;TRUST
(declare-rule ite2 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (CL Bool))
  :premises ((@cl (ite phi1 phi2 phi3)))
  :args (CL)
  :requires (((clEqual (@cl (not phi1) phi2) CL) true))
  :conclusion CL
)

;TODO
(program check_ite_pos1 ((CL Bool))
  (Bool) Bool
  (
   ((check_ite_pos1 CL) true)
  )
)

;TRUST
(declare-rule ite_pos1 ((CL Bool))
  :args (CL)
  :requires (((check_ite_pos1 CL) true))
  :conclusion CL
)

;TODO
(program check_ite_pos2 ((CL Bool))
  (Bool) Bool
  (
   ((check_ite_pos2 CL) true)
  )
)

;TRUST
(declare-rule ite_pos2 ((CL Bool))
  :args (CL)
  :requires (((check_ite_pos2 CL) true))
  :conclusion CL
)

;TODO
(program check_ite_neg1 ((CL Bool))
  (Bool) Bool
  (
   ((check_ite_neg1 CL) true)
  )
)

;TRUST
(declare-rule ite_neg1 ((CL Bool))
  :args (CL)
  :requires (((check_ite_neg1 CL) true))
  :conclusion CL
)

;TODO
(program check_ite_neg2 ((CL Bool))
  (Bool) Bool
  (
   ((check_ite_neg2 CL) true)
  )
)

;TRUST
(declare-rule ite_neg2 ((CL Bool))
  :args (CL)
  :requires (((check_ite_neg2 CL) true))
  :conclusion CL
)

;TRUST
(declare-rule not_ite1 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (CL Bool))
  :premises ((@cl (not (ite phi1 phi2 phi3))))
  :args (CL)
  :requires (((clEqual (@cl phi1 (not phi3)) CL) true))
  :conclusion CL
)

;TRUST
(declare-rule not_ite2 ((phi1 Bool) (phi2 Bool) (phi3 Bool) (CL Bool))
  :premises ((@cl (not (ite phi1 phi2 phi3))))
  :args (CL)
  :requires (((clEqual (@cl (not phi1) (not phi2)) CL) true))
  :conclusion CL
)

;TODO
(program check_connective_dev ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_connective_dev l r) true)
  )
)

;TRUST
(declare-rule connective_def ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_connective_dev l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_and_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_and_simplify l r) true)
  )
)

;TRUST
(declare-rule and_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_and_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_or_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_or_simplify l r) true)
  )
)

;TRUST
(declare-rule or_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_or_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_not_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_not_simplify l r) true)
  )
)

;TRUST
(declare-rule not_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_not_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_implies_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_implies_simplify l r) true)
  )
)

;TRUST
(declare-rule implies_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_implies_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_equiv_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_equiv_simplify l r) true)
  )
)

;TRUST
(declare-rule equiv_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_equiv_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_bool_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_bool_simplify l r) true)
  )
)

;TRUST
(declare-rule bool_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_bool_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_ac_simp ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_ac_simp l r) true)
  )
)

;TRUST
(declare-rule ac_simp ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_ac_simp l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_ite_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_ite_simplify l r) true)
  )
)

;TRUST
(declare-rule ite_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_ite_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_qnt_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_qnt_simplify l r) true)
  )
)

;TRUST
(declare-rule qnt_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_qnt_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_onepoint ((ctx Bool) (xs @VarList) (ys @VarList) (Q (-> @VarList Bool Bool)) (T Type) (phi T) (phiP T))
  (Bool (-> @VarList Bool Bool) @VarList @VarList T T) Bool
  (
   ((check_onepoint ctx Q xs ys phi phiP) true)
  )
)

;TRUST
(declare-rule onepoint ((ctx Bool) (xs @VarList) (ys @VarList) (Q (-> @VarList Bool Bool)) (T Type) (phi T) (phiP T))
  :assumption ctx
  :premises ((@cl (= phi phiP)))
  :args ((@cl (= (Q xs phi) (Q ys phiP))))
  :requires (((check_onepoint ctx Q xs ys phi phiP) true))
  :conclusion (@cl (= (Q xs phi) (Q ys phiP)))
)

;TODO
(program check_qnt_join ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_qnt_join l r) true)
  )
)

;TRUST
(declare-rule qnt_join ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_qnt_join l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_qnt_rm_unused ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_qnt_rm_unused l r) true)
  )
)

;TRUST
(declare-rule qnt_rm_unused ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_qnt_rm_unused l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_eq_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_eq_simplify l r) true)
  )
)

;TRUST
(declare-rule eq_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_eq_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_div_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_div_simplify l r) true)
  )
)

;TRUST
(declare-rule div_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_div_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_prod_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_prod_simplify l r) true)
  )
)

;TRUST
(declare-rule prod_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_prod_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_unary_minus_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_unary_minus_simplify l r) true)
  )
)

;TRUST
(declare-rule unary_minus_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_unary_minus_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_minus_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_minus_simplify l r) true)
  )
)

;TRUST
(declare-rule minus_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_minus_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_sum_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_sum_simplify l r) true)
  )
)

;TRUST
(declare-rule sum_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_sum_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_comp_simplify ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_comp_simplify l r) true)
  )
)

;TRUST
(declare-rule comp_simplify ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_comp_simplify l r) true))
  :conclusion (@cl (= l r))
)

;TODO
;This has to traverse the lets and the premises
(program check_let ((ctx Bool) (Cs Bool) (l Bool) (r Bool))
  (Bool Bool Bool Bool) Bool
  (
   ((check_let ctx Cs l r) true)
  )
)

(declare-rule let_elim ((ctx Bool) (Cs Bool) (l Bool) (r Bool))
  :assumption ctx
  :premise-list Cs and
  :args ((@cl (= l r)))
  :requires (((check_let ctx Cs l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_distinct_elim ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_distinct_elim l r) true)
  )
)

;TRUST
(declare-rule distinct_elim ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_distinct_elim l r) true))
  :conclusion (@cl (= l r))
)

; TODO: other number types. Can the equality be flipped?
(declare-rule la_rw_eq ((t Real) (u Real))
  :args ((@cl (= (= t u) (and (<= t u) (<= u t)))))
  :conclusion (@cl (= (= t u) (and (<= t u) (<= u t))))
)

;TODO
(program check_nary_elim ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_nary_elim l r) true)
  )
)

;TRUST
(declare-rule nary_elim ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_nary_elim l r) true))
  :conclusion (@cl (= l r))
)

;TODO
(program check_bfun_elim ((psi Bool) (phi Bool))
  (Bool Bool) Bool
  (
   ((check_bfun_elim psi phi) true)
  )
)

;TRUST
(declare-rule bfun_elim ((psi Bool) (phi Bool))
  :premises ((@cl psi))
  :args ((@cl phi))
  :requires (((check_bfun_elim psi phi) true))
  :conclusion (@cl phi)
)

;TODO
(program check_ite_intro ((l Bool) (r Bool))
  (Bool Bool) Bool
  (
   ((check_ite_intro l r) true)
  )
)

;TRUST
(declare-rule ite_intro ((l Bool) (r Bool))
  :args ((@cl (= l r)))
  :requires (((check_ite_intro l r) true))
  :conclusion (@cl (= l r))
)

